#!/bin/bash

#This file should be cp to /var/lib/lxc/$containerName$/rootfs/usr/local/bin/optilion

COMMAND=$1 && shift
while [[ $# -gt 0 ]] ; do
	case $1 in
		-ph|path)			LXCPATH=$2 && shift ;;
		-sf|sourcefile) 	SOURCEFILE=$2 && shift ;;
		-bf|binaryfile) 	BINARYFILE=$2 && shift ;;
		-in|input)			INPUT=$2 && shift ;;
		-out|output)		OUTPUT=$2 && shift ;;
		-err|errpur)		ERRPUT=$2 && shift ;;
		-stat|statput)		STATPUT=$2 && shift ;;
		-l|language)		LANGUAGE=$2 && shift ;;
		-m|memout)			MEMOUT=$2 && shift ;;
		-t|timeout)			TIMEOUT=$2 && shift ;;
		-tl|timelimit)		TIMELIMIT=$2 && shift ;;
		-sb|serverfile)		SERVERFILE=$2 && shift ;;
		-sm|servermode)		SERVERMODE=$2 && shift ;;
		-sp|serverparams)	SERVERPARAMS=$2 && shift ;;
		-jf|judgefile)		JUDGEFILE=$2 && shift ;;
		-ii|instanceinput)	IINPUT=$2 && shift ;;
		-uo|useroutput)		UOUTPUT=$2 && shift ;;
		-io|instanceoutput)	IOUTPUT=$2 && shift ;;
		-ut|usertime)       USERTIME=$2 && shift ;;
		-pt|perftime)       PERFTIME=$2 && shift ;;
		-d|debug)			DEBUG=$2 && shift ;;
		-up|userparams)		USERPARAMS=$2 && shift ;;
		*) ;;
	esac
	shift
done

# Requires path, sourcefile, binaryfile
compile(){
	${LXCPATH}compileHelper.sh ${LXCPATH} "${SOURCEFILE}" ${BINARYFILE}
}

# Requires $1 - pid, path, timeout, timelimit, memout
monitor(){
	start=$(($(date +%s%N)/1000000))
	pid="${1}"
	timeLimitSend="n"
	if [ "${pid}" = "" ] ; then
		exit 2
	fi	

	ticks=`perl -e 'use POSIX;print POSIX::sysconf(&POSIX::_SC_CLK_TCK)'`

	while  cat /proc/${pid}/status 2>/dev/null | grep "VmPeak:" >> ${LXCPATH}mem.log ; do
		mem=`cat ${LXCPATH}mem.log | tail -n 1 | sed 's/VmPeak:\s*\([0-9]*\)\s*kB/\1/' | tr -d '\n'`
		if  [ "${LANGUAGE}" != "JAVA"  ] && [ "${LANGUAGE}" != "JAR" ] && [ "${LANGUAGE}" != "JAVASCRIPT" ] && [ "${mem}" != "" ] && [ ${mem} -gt ${MEMOUT} ] ; then
			kill -s 9 ${pid}
			exit 123
		fi
		
		time=`cat /proc/${pid}/stat 2>/dev/null | cut -d " " -f 14`
		if [ "${time}" != "" ] ; then
			echo ${time} >> ${LXCPATH}clockTicks.log
		fi

		if  [ "${timeLimitSend}" = "n" ] && [ "${TIMELIMIT}" != "" ] && [ "${time}" != "" ] && [ "$((${time}/${ticks}))" -ge "${TIMELIMIT}" ] ; then
			timeLimitSend="y"
			kill -15 ${pid}
		fi

		if [ "${time}" != "" ] && [ "$((${time}/${ticks}))" -ge "${TIMEOUT}" ] ; then
			kill -9 ${pid}
			exit 124
		fi
		
		end=$(($(date +%s%N)/1000000))
		if [ "$((${end}-${start}))" -ge "$((1300*${TIMEOUT}))" ] ; then
			kill -9 ${pid}
			exit 124
		fi
		
		if [ "${timeLimitSend}" = "n" ] && [ "$((${end}-${start}))" -ge "$((1200*${TIMEOUT}))" ] ; then
			timeLimitSend="y"
			kill -15 ${pid}
		fi
    
    numOfSubProces=`ps --no-headers --ppid ${pid} | wc -l | tr -d '\n'`
    if [ ${numOfSubProces} -gt 0 ] ; then
      kill -9 ${pid}
      exit 122
    fi
    numOfSubThreads=`ps --no-headers -T -p ${pid} | wc -l | tr -d '\n'`
    if [ ${numOfSubThreads} -gt 500 ] ; then
      kill -9 ${pid}
      exit 121
    fi

		
		sleep 0.1      
        done
}

# Requires path, binaryfile, input, output, errput, statput, language, memout, timeout
# Optional port, host (for interactive runs) 
# Result:
#  In 'output' is output of binFileNam
#  In 'errput' is error stream of binFileNam
#  In 'statput' is result of 'perf stat'
#  In 'memstat' is mesurment of memory (cat /proc/pid/status | grep VmSize:)
# !!! visudo must be set so that no password is needed!
run(){
# For some reason ulimit -u generated some problems
#	ulimit -u 500
	touch ${LXCPATH}perf.log
	touch ${OUTPUT}
	touch ${ERRPUT}
	
	if [ "${INTERACTIVE}" == "" ] ; then
		perf stat -x ";" -o ${LXCPATH}perf.log ${LXCPATH}runHelper.sh ${LXCPATH} "${BINARYFILE}" ${INPUT} ${OUTPUT} ${ERRPUT} "${USERPARAMS}" &
		perfpid=`echo $!`
	else
		perf stat -x ";" -o ${LXCPATH}perf.log ${LXCPATH}runHelper.sh ${LXCPATH} "${BINARYFILE}" ${OUTPUT} ${ERRPUT} ${SERVERMODE} ${SERVERPARAMS} &
		perfpid=`echo $!`
	fi

	echo "perfpid=${perfpid}" > ${LXCPATH}opt.log

	#Dont remember what this do. Sudo is no longer used so I get perfpid immediately
	
	# We wait until the child is created
	# If child executes very quickly then parent is killed and second condition is false
	#while [ "${perfpid}" = "" ] && [ -e /proc/${sudopid}/status ] ; do
	#	perfpid=`ps --ppid ${sudopid} -o pid=`
	#	if [ "${perfpid}" != "" ] && [ `ps --pid ${perfpid} -o command= | grep --regexp ".*/usr/lib/linux.*stat.*" | wc -l` -ne 1 ] ; then
	#		perfpid=""
	#	fi
	#done

  while ( [ "${runpid}" = "" ] || [ "${runhelppid}" = "" ] ) && [ -e /proc/${perfpid}/status ] ; do
    runhelppid=`ps --ppid ${perfpid} -o pid=`
    if [ "${runhelppid}" != "" ] && [ `ps --pid ${runhelppid} -o command= | grep runHelper.sh | wc -l` -ne 1 ] ; then
      runhelppid=""
    fi
    if [ "${runhelppid}" != "" ] ; then
      runpid=`ps --ppid ${runhelppid} -o pid=`
    fi
  done

  echo "runhelppid=${runhelppid}" >> ${LXCPATH}opt.log
  echo "runpid=${runpid}" >> ${LXCPATH}opt.log

	# runpid could be pipexec process
	if [ "${INTERACTIVE}" != "" ] ; then
		while [ "${tmprunpid}" = "" ] && [ -e /proc/${perfpid}/status ] ; do
			tmprunpid=`ps --ppid ${runpid} -o pid=,command= | sed -e 's/^[ \t]*//' | grep "${LXCPATH}${BINARYFILE}" | cut -d ' ' -f 1`
		done
		runpid=${tmprunpid}
		echo "runpid(interactive)=${runpid}" >> ${LXCPATH}opt.log
	fi	

	monitor ${runpid} &
	monitorpid=`echo $!`	

	if [ "${DEBUG}" != "" ] ; then
		echo "perfpid=${perfpid}"
		echo "runhelppid=${runhelppid}"
		echo "runpid=${runpid}"
		echo "monitorpid=${monitorpid}"
	fi

	echo "monitorpid=${monitorpid}" >> ${LXCPATH}opt.log

	wait ${perfpid}
	perfexit=`echo $?`

	wait ${monitorpid}
	monitorexit=`echo $?`
	
	if [ "${DEBUG}" != "" ] ; then
		echo "monitorexit=${monitorexit}"
		echo "perfexit=${perfexit}"
	fi

	clockTicks=`cat ${LXCPATH}clockTicks.log 2>/dev/null | tail -n 1 | tr -d '\n'`
	instructions=`cat ${LXCPATH}perf.log 2>/dev/null | grep instructions | cut -d ";" -f1 | tr -d '\n'`
	memsize=`cat ${LXCPATH}mem.log | tail -n 1 | sed 's/VmPeak:\s*\([0-9]*\)\s*kB/\1/' | tr -d '\n'`
	
	if [ "${clockTicks}" = "" ] ; then
		clockTicks="0"
	fi
	if [ "${instructions}" = "" ] || [ "${instructions}" = "<not supported>" ] ; then
		instructions="0"
	fi
	if [ "${memsize}" = "" ] ; then
		memsize="0"
	fi

	echo ${clockTicks}";"${instructions}";"${memsize} | tr -d '\n' > ${STATPUT}
	# Check pipexec log file for process exit code
	if [ -e ${LXCPATH}pipexec.log ] ; then
		tmppid=$(awk -F'\\[|\\]' '/\[A\] New child pid/ {print $4 }' ${LXCPATH}pipexec.log)
		ex=$(awk -v pid="${tmppid}" -F'\\[|\\]' '$0 ~ "Child \\["pid"\\] exit with status" {print $4 }' ${LXCPATH}pipexec.log)
	fi
 
	echo ${clockTicks}";"${instructions}";"${memsize} | tr -d '\n' > ${STATPUT}
 
 	echo "monitorexit=${monitorexit}" >> ${LXCPATH}opt.log
	echo "pidFromPipexc.log=${tmppid}" >> ${LXCPATH}opt.log
	echo "pipexcExit=${ex}" >> ${LXCPATH}opt.log
 
	if [ "${monitorexit}" -eq "124" ] ; then 
		exit 124
	fi
	if [ "${monitorexit}" -eq "123" ] ; then
		exit 123
	fi
	if [ "${monitorexit}" -eq "122" ] ; then
		exit 122
	fi

	if [ "${ex}" != "" ] ; then
		exit ${ex}
	fi

	exit ${perfexit}
}

# Requires, same as for run -> no longer  host, port, servefile, servermode, serverparams
runIterative(){
	INTERACTIVE="true"
	run
}

# Requires path, judgefile, instanceinput, useroutput, unstanceoutput
judge(){
	"${LXCPATH}${JUDGEFILE}" "${LXCPATH}${IINPUT}" "${LXCPATH}${UOUTPUT}" "${LXCPATH}${IOUTPUT}" "${USERTIME}" "${PERFTIME}"
	exit $? 
}

# Requires path, serverfile, servermode, serverparams, useroutput
interactiveJudge(){
	"${LXCPATH}${SERVERFILE}" "${SERVERMODE}" "${SERVERPARAMS}" "${LXCPATH}${UOUTPUT}"
}

if [ "${DEBUG}" != "" ] ; then
	echo "LXCPATH=${LXCPATH}"
	echo "SOURCEFILE=${SOURCEFILE}"
	echo "BINARYFILE=${BINARYFILE}"
	echo "INPUT=${INPUT}"
	echo "OUTPUT=${OUTPUT}"
	echo "ERRPUT=${ERRPUT}"
	echo "STATPUT=${STATPUT}"
	echo "LANGUAGE=${LANGUAGE}"
	echo "MEMOUT=${MEMOUT}"
	echo "TIMEOUT=${TIMEOUT}"
	echo "SERVERFILE=${SERVERFILE}"
	echo "SERVERMODE=${SERVERMODE}"
	echo "SERVERPARAMS=${SERVERPARAMS}"
	echo "JUDGEFILE=${JUDGEFILE}"
	echo "IINPUT=${IINPUT}"
	echo "UOUTPUT=${UOUTPUT}"
	echo "IOUTPUT=${IOUTPUT}"
	echo "DEBUG=${DEBUG}"
fi

${COMMAND}
